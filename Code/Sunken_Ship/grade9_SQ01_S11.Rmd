---
title: "S11"
author: "zifengxu"
date: "2024-02-10"
output: html_document
---

# Read the Data (PSI)
```{r}
library(haven)
library(dplyr)
library(stringr)
library(tidyr)
library(jsonlite)
```

```{r}
df <- read_sav("../data/grade9/BSLNORZ7_PSI.sav")

# Explore the data
head(df)
```

Remove the rows of auto check for this question
```{r}
df_filter = df%>%
  filter(!(PSIVariableIdentifier == 5051 | PSIVariableIdentifier == 5056) | is.na(df$PSIVariableIdentifier))
```

Filter the rows and exactly one row above the row that satisfied one of the conditions below: 

Condition 1: BlockName=SQ01, BookletPart=1, BlockInPart=2, currentindex=25.

Condition 2: BlockName=SQ01, BookletPart=2, BlockInPart=1, currentindex=11.

```{r}
condition1 <- df_filter$BlockName == 'SQ01' & 
              df_filter$BookletPart == 1 & 
              df_filter$BlockInPart == 2 & 
              df_filter$currentindex == 25 

# Define the second condition
condition2 <- df_filter$BlockName == 'SQ01' & 
              df_filter$BookletPart == 2 & 
              df_filter$BlockInPart == 1 & 
              df_filter$currentindex == 11 

# Combine the two conditions using OR (|) as you want rows satisfying either condition
combined_condition <- condition1 | condition2

# Use filter to get the rows that satisfy the conditions and one row below
result11 <- df_filter %>% 
  filter(combined_condition | lag(combined_condition, default = FALSE))

result11
```


### Module Path
Create a new column module_path based on (BlockName, BookletPart, BlockInPart, currentindex)
```{r}
result_use_Q11= transform(result11,
                       module_path = paste0("(", BlockName, ", ", BookletPart, ", ", BlockInPart, ")"))
head(result_use_Q11)
```

```{r}
unique(result_use_Q11$eventname)
```


### Time
```{r}
result_filter_Q11=result_use_Q11 %>%filter(eventname %in% c("Nav:GoTo", "Response", "UI:Scrollbar", "Btn:Calc"))
result_filter_Q11
```

```{r}
result_time_complete_Q11=result_filter_Q11 %>%
  mutate(SQ01S11_time = ifelse(currentindex == 25 & eventname == 'Nav:GoTo' | currentindex == 11 & eventname == 'Nav:GoTo', 0, ifelse(timemilisec - lag(timemilisec) > 0,
                                      (timeunixsec - lag(timeunixsec) + (timemilisec - lag(timemilisec))/1000),
                                      (timeunixsec - lag(timeunixsec) - 1 + (timemilisec + 1000 - lag(timemilisec))/1000))))
# head(result_time_complete_Q11[c("idstud","module_path","SQ01S11_time")])

# result_time_complete_Q11
```

```{r}
result_time_complete_Q11 = result_time_complete_Q11%>%
  mutate(RowNumber = row_number())
```

```{r}
result_time_complete_Q11$SQ01S11_unit_time <- result_time_complete_Q11$timeunixsec * 1000 + result_time_complete_Q11$timemilisec

# show all the units
result_time_complete_Q11$SQ01S11_unit_time <- format(result_time_complete_Q11$SQ01S11_unit_time, scientific = FALSE)
```

```{r}
result_time_complete_Q11
```


### Fill in declicking 
If the column PSIVariableIdentifier == 5053 and the column information is empty, then fill "declick" into the column information.
```{r}
result_declick_Q11 <- result_time_complete_Q11 %>%
  mutate(information = ifelse(PSIVariableIdentifier == 5053 & information == "", "declick", information))

result_declick_Q11
```


```{r}
result_declick_Q11[result_declick_Q11$PSIVariableIdentifier==5053,]
```

```{r}
result_time_complete_Q11[result_time_complete_Q11$PSIVariableIdentifier==5053,]
```



### Blue Circle Sequence
Create a new column SQ01S11_sequence to store the sequence that student slide the blue circle based on the following conditions:

Filter the data by using PSIVariableIdentifier == 5052, which means the students move the blue circle. Then group by the student id, the new column SQ01S11_scale_sequence should created based on the sequence of the value of the column information in the order of if the row number is higher, their sequence should be higher.

```{r}
# Filter data and arrange by idstud and information
df_filtered <- result_time_complete_Q11 %>%
  filter(PSIVariableIdentifier == 5052)%>%
  group_by(idstud) %>%
  mutate(SQ01S11_sequence_list = list(information[order(row_number())]))

# Convert the list column to a new column with the desired format, and then drop the list column
df_filtered$SQ01S11_scale_sequence <- sapply(df_filtered$SQ01S11_sequence_list, function(x) paste0("(", toString(x), ")"))

df_filtered
```

Create a new dataframe by merge the two dataframes by using the column idstud, and RowNumber. 
```{r}
df_filtered_merge = df_filtered[c("idstud","RowNumber","SQ01S11_scale_sequence")]
```

```{r}
result_seq_Q11 <- merge(result_time_complete_Q11, df_filtered_merge, by = c("idstud","RowNumber"), all = TRUE)
# head(result_seq_Q11)
```

Then fill in all the missing value of the column SQ01S11_scale_sequence according to the student name.
```{r}
result_seq_Q11=result_seq_Q11%>%
  group_by(idstud) %>%
  fill(SQ01S11_scale_sequence, .direction = "downup")
result_seq_Q11
```

Check the missing value, there exists missing value because some students do not do this step.
```{r}
# result_seq_Q11[is.na(result_seq_Q11$SQ01S11_sequence), ]
# result_seq_Q11[result_seq_Q11$idstud==50180606,]
```


### Time in between the Sequence
Then record the time taken for each time they move the blue circle. Filter by PSIVariableIdentifier == 5052 which means the students move the blue circle. Then group by the student id, the new column SQ01S11_scale_seq_time should created based on the sequence of the value of the column SQ01S11_time in the order of if the row number is higher, their sequence should be higher.
```{r}
# Filter data and arrange by idstud and SQ01S11_time
df_filtered <- result_time_complete_Q11 %>%
  filter(PSIVariableIdentifier == 5052)%>%
  group_by(idstud) %>%
  mutate(SQ01S11_seq_time_list = list(SQ01S11_time[order(row_number())]))

# Convert the list column to a new column with the desired format, and then drop the list column
df_filtered$SQ01S11_scale_seq_time <- sapply(df_filtered$SQ01S11_seq_time_list, function(x) paste0("(", toString(x), ")"))

df_filtered
```


```{r}
# create a new dataframe to merge
df_filtered_merge = df_filtered[c("idstud","RowNumber","SQ01S11_scale_seq_time")]

# merge the data
result_seqtime_Q11 <- merge(result_seq_Q11, df_filtered_merge, by = c("idstud","RowNumber"), all = TRUE)

# fill the missing value of the column SQ01S11_sequence based on the student name
result_seqtime_Q11=result_seqtime_Q11%>%
  group_by(idstud) %>%
  fill(SQ01S11_scale_seq_time, .direction = "downup")
result_seqtime_Q11
```


### recheck
create a new column SQ01S11_recheck based on the following rule:
filter by PSIVariableIdentifier == 5052 or PSIVariableIdentifier == 5053 or 5054, groupby idstud, If there exist PSIVariableIdentifier == 5052 after PSIVariableIdentifier == 5053 or 5054 for the idstud, then the new column SQ01S11_recheck == 1 for this idstud, otherwise, return 0 for this idstud.

```{r}
# Filter data and arrange by idstud and information
df_filtered <-result_time_complete_Q11 %>%
  filter(PSIVariableIdentifier %in% c(5052, 5053, 5054)) %>%
  group_by(idstud) %>%
  mutate(SQ01S11_recheck = if_else(
    any(PSIVariableIdentifier == 5052 & lag(PSIVariableIdentifier) == 5053, na.rm = TRUE) |
    any(PSIVariableIdentifier == 5052 & lag(PSIVariableIdentifier) == 5054, na.rm = TRUE),
    1,
    0
  ))
df_filtered
```

```{r}
df_filtered[c("idstud","information","SQ01S11_recheck","RowNumber")]
```

```{r}
# merge the dataframe
df_filtered_merge = df_filtered[c("idstud","RowNumber","SQ01S11_recheck")]
result_recheck_S11 <- merge(result_seqtime_Q11, df_filtered_merge, by = c("idstud","RowNumber"), all = TRUE)

# fill the missing value
result_recheck_S11=result_recheck_S11%>%
  group_by(idstud) %>%
  fill(SQ01S11_recheck, .direction = "downup")

result_recheck_S11
```


### Choice in Sequence
Filter the data by PSIVariableIdentifier == 5053. Then group by the student id, the new column SQ01S11_choice_sequence should created based on the sequence of the value of the column information in the order of if the row number is higher, their sequence should be higher.
```{r}
# Filter data and arrange by idstud and information
df_filtered <- result_time_complete_Q11 %>%
  filter(PSIVariableIdentifier == 5053)%>%
  group_by(idstud) %>%
  mutate(SQ01S11_sequence_list = list(information[order(row_number())]))

# Convert the list column to a new column with the desired format, and then drop the list column
df_filtered$SQ01S11_choice_sequence <- sapply(df_filtered$SQ01S11_sequence_list, function(x) paste0("(", toString(x), ")"))

# df_filtered
```

Create a new dataframe by merge the two dataframes by using the column idstud, and RowNumber.
```{r}
df_filtered_merge = df_filtered[c("idstud","RowNumber","SQ01S11_choice_sequence")]
```

```{r}
result_choice_seq_Q11 <- merge(result_recheck_S11, df_filtered_merge, by = c("idstud","RowNumber"), all = TRUE)
# result_choice_seq_Q11
```

Then fill in all the missing value of the column SQ01S11_choice_sequence according to the student name.
```{r}
result_choice_seq_Q11=result_choice_seq_Q11%>%
  group_by(idstud) %>%
  fill(SQ01S11_choice_sequence, .direction = "downup")
result_choice_seq_Q11
```


### Final Choice
Create a new column SQ01S11_final_choice. Filter the data by using PSIVariableIdentifier == 5053 and IsfinalAnswer ==1, then groupby idstud, SQ01S11_final_choice = information.
```{r}
# Filter the data based on PSIVariableIdentifier == 5053
filtered_data <- result_time_complete_Q11 %>% filter(PSIVariableIdentifier == 5053)%>%
filter(IsFinalAnswer == 1)

# Group by idstud and create the new column SQ01S11_final_choice
result <- filtered_data %>%
  group_by(idstud) %>%
  summarise(SQ01S11_final_choice = information)

# Merge the result back to the original data frame
result_Final_choice_Q11 <- merge(result_choice_seq_Q11, result, by = "idstud", all.x = TRUE)
```


```{r}
# result_Final_choice_Q11[c("idstud","eventname","IsFinalAnswer","PSIVariableIdentifier","information","SQ01S11_final_choice")]
result_Final_choice_Q11
```


### Word Count 
Filter the data based on PSIVariableIdentifier == 5054 & IsFinalAnswer == 1.
```{r}
# Filter the data based on PSIVariableIdentifier == 5054
filtered_data <- result_time_complete_Q11 %>% filter(PSIVariableIdentifier == 5054)%>%
filter(IsFinalAnswer == 1)
```

```{r}
length(unique(filtered_data$idstud))
```

Create a new column SQ01S11_wordcount_punc that count the number of words in the column information including the punctuations.
```{r}
# Function to split words and punctuations
split_words_and_punctuations <- function(text) {
  # Match words and punctuations separately
  tokens <- strsplit(text, "(?<=[a-zA-Z0-9])(?=[[:punct:]])|(?<=[[:punct:]])(?=[a-zA-Z0-9])|\\s+", perl=TRUE)[[1]]
  # Remove empty tokens
  tokens <- tokens[tokens != ""]
  return(tokens)
}

# Apply the function to the information column
filtered_data$SQ01S11_wordcount_punc <- sapply(filtered_data$information, function(x) length(split_words_and_punctuations(x)))
```
Use (?<=[a-zA-Z0-9])(?=[[:punct:]])|(?<=[[:punct:]])(?=[a-zA-Z0-9]) split words and punctuations separately, and use |\\s+ matches one or more whitespace characters. Then count the total number of tokens.

excluding the punctuations
```{r}
filtered_data <- mutate(filtered_data, SQ01S11_wordcount_no_punc = str_count(gsub("[-[:punct:]]", " ", information), "\\S+"))
filtered_data[c("idstud","information","module_path","SQ01S11_wordcount_punc","SQ01S11_wordcount_no_punc")]
```

Merge the data to the original data
```{r}
# df_filtered_merge = df_filtered[c("idstud","RowNumber","SQ01S11_wordcount_punc","SQ01S11_wordcount_no_punc")]
df_filtered_merge = filtered_data[c("idstud","SQ01S11_wordcount_punc","SQ01S11_wordcount_no_punc")]
```

```{r}
# Merge the result back to the original data frame
result_wordcount_Q11 <- merge(result_Final_choice_Q11, df_filtered_merge, by = "idstud", all.x = TRUE)
result_wordcount_Q11
```


### Raw Response
Create a new column SQ01S11_raw_response that is exactly same as the column information of the filtered data.
```{r}
filtered_data$SQ01S11_raw_response <- filtered_data$information

df_filtered_merge = filtered_data[c("idstud","SQ01S11_raw_response")]
```

```{r}
# Merge the result back to the original data frame
result_wordres_Q11 <- merge(result_wordcount_Q11, df_filtered_merge, by = "idstud", all.x = TRUE)
result_wordres_Q11[c("SQ01S11_raw_response","SQ01S11_wordcount_no_punc","SQ01S11_wordcount_punc")]
```
`

### All Steps
Create a new dataframe by copy the original one.Create a new column step_str based on the other column.
If PSIVariableIdentifier == 5052, then step_str == "move_scale_"+ value of the column information
If PSIVariableIdentifier == 5053, then step_str == "select_option_" + value of the column information
If PSIVariableIdentifier == 5054, then step_str == "write_explanation"
If eventname == "Nav:GoTo" & new_currentindex == 11, then step_str == "Begin_Q11"
If eventname == "Nav:GoTo" & new_currentindex != 11, then step_str == "Nevigate_to_Q"+ value of the column new_currentindex
If eventname == "UI:Scrollbar", step_str == extract the value after event and scrollTop in the column information.
If eventname == "Btn:Calc", step_str == "Calculator" + extract the value after To in the column information.

Create a column new_currentindex by changing the column currentindex based on the rule below:
15 to 1, 16 to 2, 17 to 3, 18 to 4, 19 to 5, 20 to 6, 21 to 7, 22 to 8, 23 to 9, 24 to 10, 25 to 11, 26 to 12, 27 to 13, 28 to 14
```{r}
result_copy_Q11=data.frame(result_declick_Q11)
result_copy_Q11 <- result_copy_Q11 %>%
  mutate(new_currentindex = case_when(
    currentindex == 14 & BookletPart == 1 ~ 0,
    currentindex == 15 ~ 1,
    currentindex == 16 ~ 2,
    currentindex == 17 ~ 3,
    currentindex == 18 ~ 4,
    currentindex == 19 ~ 5,
    currentindex == 20 ~ 6,
    currentindex == 21 ~ 7,
    currentindex == 22 ~ 8,
    currentindex == 23 ~ 9,
    currentindex == 24 ~ 10,
    currentindex == 25 ~ 11,
    currentindex == 26 ~ 12,
    currentindex == 27 ~ 13,
    currentindex == 28 ~ 14,
    TRUE ~ currentindex  # Keep the original value if it doesn't match any rule
  ))
```

```{r}
result_str_Q11<- result_copy_Q11 %>%
  mutate(
    step_str = case_when(
      PSIVariableIdentifier == 5052 ~ paste0("move_scale_", information),
      PSIVariableIdentifier == 5053 ~ paste0("select_option_", information),
      PSIVariableIdentifier == 5054 ~ "write_explanation",
      eventname == "Nav:GoTo" & new_currentindex == 11 ~ "Begin_Q11",
      eventname == "Nav:GoTo" & new_currentindex != 11 ~ paste0("Navigate_to_Q", new_currentindex),
      eventname == "UI:Scrollbar" ~ sub('.*"event":"([^"]+).*"scrollTop":(\\d+).*', '\\1 \\2', information),
      eventname == "Btn:Calc" ~ paste0("Calculator_", gsub('.*To":"(\\w+).*', '\\1', information)),
      TRUE ~ NA_character_  # If none of the conditions are met, set to NA
    )
  )
result_str_Q11[c("RowNumber","step_str","information")]
```
 
If the row of value of the column eventname == "UI:Scrollbar", then the value of the row of the column step_str substitute the white space to _.
```{r}
result_str_use_Q11 <- result_str_Q11 %>%
  mutate(step_str = ifelse(eventname == "UI:Scrollbar", gsub(" ", "_", step_str), step_str))
result_str_use_Q11[c("RowNumber","step_str","information")]
```

```{r}
# Filter data and create a list to record all the steps needed.
df_filtered <- result_str_use_Q11 %>%
  filter(!is.na(step_str)) %>%
  group_by(idstud) %>%
  mutate(SQ01S11_allsteps_list = list(step_str[order(row_number())]))

# Convert the list column to a new column with the desired format, and then drop the list column
df_filtered$SQ01S11_allsteps_seq <- sapply(df_filtered$SQ01S11_allsteps_list, function(x) paste0("(", toString(x), ")"))
```

```{r}
df_filtered <- select(df_filtered, -SQ01S11_allsteps_list)
df_filtered_merge = df_filtered[c("idstud","RowNumber","SQ01S11_allsteps_seq")]

result_allsteps_Q11 <- merge(result_wordres_Q11, df_filtered_merge, by = c("idstud","RowNumber"), all = TRUE)

result_allsteps_Q11=result_allsteps_Q11%>%
  group_by(idstud) %>%
  fill(SQ01S11_allsteps_seq, .direction = "downup")

result_allsteps_Q11
```

```{r}
result_allsteps_Q11[c("idstud","SQ01S11_allsteps_seq","information")]
```


### Timestamp for All Steps in milisecond
create a column to record the time taken for each single steps for each student to do this problem.
```{r}
# Filter data and create a list to record all the steps needed.
df_filtered <- result_str_use_Q11 %>%
  group_by(idstud) %>%
  mutate(SQ01S11_allsteps_list = list(SQ01S11_time[order(row_number())]))

# Convert the list column to a new column with the desired format, and then drop the list column
df_filtered$SQ01S11_allsteps_seq_time <- sapply(df_filtered$SQ01S11_allsteps_list, function(x) paste0("(", toString(x), ")"))

# filter the data and select column to merge
df_filtered <- select(df_filtered, -SQ01S11_allsteps_list)
df_filtered_merge = df_filtered[c("idstud","RowNumber","SQ01S11_allsteps_seq_time")]

# merge the data
result_alls_time_Q11 <- merge(result_allsteps_Q11, df_filtered_merge, by = c("idstud","RowNumber"), all = TRUE)

result_alls_time_Q11=result_alls_time_Q11%>%
  group_by(idstud) %>%
  fill(SQ01S11_allsteps_seq_time, .direction = "downup")
result_alls_time_Q11
```


### Unit Time for All Steps
create a column to record the time taken for each single steps for each student to do this problem.
```{r}
# Filter data and create a list to record all the steps needed.
df_filtered <- result_str_use_Q11 %>%
  group_by(idstud) %>%
  mutate(SQ01S11_allsteps_list = list(SQ01S11_unit_time[order(row_number())]))

# Convert the list column to a new column with the desired format, and then drop the list column
df_filtered$SQ01S11_allsteps_timestamp <- sapply(df_filtered$SQ01S11_allsteps_list, function(x) paste0("(", toString(x), ")"))

# filter the data and select column to merge
df_filtered <- select(df_filtered, -SQ01S11_allsteps_list)
df_filtered_merge = df_filtered[c("idstud","RowNumber","SQ01S11_allsteps_timestamp")]

# merge the data
result_all_unit_time_Q11 <- merge(result_alls_time_Q11, df_filtered_merge, by = c("idstud","RowNumber"), all = TRUE)

result_all_unit_time_Q11=result_all_unit_time_Q11%>%
  group_by(idstud) %>%
  fill(SQ01S11_allsteps_timestamp, .direction = "downup")
result_all_unit_time_Q11
```

### Total time taken
Create a new column SQ01S11_total_time. Group by idstud, SQ01S11_total_time = sum the value of the column SQ01S11_time for each idstud.

```{r}
# Group by idstud and calculate the sum of SQ01S11_time
result <- result_time_complete_Q11 %>%
  group_by(idstud) %>%
  summarise(SQ01S11_total_time = sum(SQ01S11_time, na.rm = TRUE))

# Merge the result back to the original data frame
result_total_time_Q11 <- merge(result_all_unit_time_Q11, result, by = "idstud", all.x = TRUE)
```

```{r}
result_total_time_Q11
# result_total_time_Q11[c("idstud","SQ01S11_time","SQ01S11_total_time")]
```


### Save the data
Filter the columns of data frame, only keep the new created columns and idstud, idstud_ori, ImportLogID, BlockName, BookletPart, BlockInPart.
```{r}
resultS11 <- result_total_time_Q11 %>%
  select(idstud, idstud_ori, ImportLogID, BlockName, BookletPart,BlockInPart, module_path, SQ01S11_scale_sequence, SQ01S11_scale_seq_time, SQ01S11_recheck, SQ01S11_choice_sequence, SQ01S11_final_choice, SQ01S11_wordcount_punc, SQ01S11_wordcount_no_punc, SQ01S11_raw_response, SQ01S11_allsteps_seq, SQ01S11_allsteps_seq_time, SQ01S11_allsteps_timestamp, SQ01S11_total_time)
# resultS11
```


```{r}
resultS11_save = resultS11[!duplicated(resultS11), ]

condition1 <- resultS11_save$BlockName == 'SQ01' & 
              resultS11_save$BookletPart == 1 & 
              resultS11_save$BlockInPart == 2 

condition2 <- resultS11_save$BlockName == 'SQ01' & 
              resultS11_save$BookletPart == 2 & 
              resultS11_save$BlockInPart == 1

combined_condition <- condition1 | condition2

resultS11_save=resultS11_save%>%ungroup()%>% 
  filter(combined_condition)
resultS11_save
```

Save the dataframe
```{r}
# write_sav(resultS11_save, "../new_data/grade9/SQ12S11_PSI.sav")

# write.csv(resultS11_save, file = 'csv_SQ12S11_PSI.csv', row.names = FALSE)
```




